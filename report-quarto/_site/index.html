<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Gustavo Chaves Ferreira e Julio Guerra Domingues">

<title>Relatório de Compressão e Descompressão com LZW – Relatório TP1 Algoritmos 2</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Relatório TP1 Algoritmos 2</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#algoritmo-de-compressão-lzw-com-trie-compacta" id="toc-algoritmo-de-compressão-lzw-com-trie-compacta" class="nav-link active" data-scroll-target="#algoritmo-de-compressão-lzw-com-trie-compacta">Algoritmo de Compressão LZW com Trie Compacta</a>
  <ul class="collapse">
  <li><a href="#introdução" id="toc-introdução" class="nav-link" data-scroll-target="#introdução">Introdução</a></li>
  <li><a href="#descrição-do-algoritmo-lzw" id="toc-descrição-do-algoritmo-lzw" class="nav-link" data-scroll-target="#descrição-do-algoritmo-lzw">Descrição do Algoritmo LZW</a>
  <ul class="collapse">
  <li><a href="#processo-de-compressão" id="toc-processo-de-compressão" class="nav-link" data-scroll-target="#processo-de-compressão">Processo de Compressão</a></li>
  <li><a href="#processo-de-descompressão" id="toc-processo-de-descompressão" class="nav-link" data-scroll-target="#processo-de-descompressão">Processo de Descompressão</a></li>
  </ul></li>
  <li><a href="#implementação" id="toc-implementação" class="nav-link" data-scroll-target="#implementação">Implementação</a>
  <ul class="collapse">
  <li><a href="#detalhes-da-implementação" id="toc-detalhes-da-implementação" class="nav-link" data-scroll-target="#detalhes-da-implementação">Detalhes da Implementação</a></li>
  </ul></li>
  <li><a href="#principais-classes" id="toc-principais-classes" class="nav-link" data-scroll-target="#principais-classes">Principais Classes</a>
  <ul class="collapse">
  <li><a href="#classe-compacttrienode" id="toc-classe-compacttrienode" class="nav-link" data-scroll-target="#classe-compacttrienode">Classe <code>CompactTrieNode</code></a></li>
  <li><a href="#classe-compacttrie" id="toc-classe-compacttrie" class="nav-link" data-scroll-target="#classe-compacttrie">Classe <code>CompactTrie</code></a></li>
  <li><a href="#classe-trielzw" id="toc-classe-trielzw" class="nav-link" data-scroll-target="#classe-trielzw">Classe <code>TrieLZW</code></a></li>
  </ul></li>
  <li><a href="#fluxo-do-algoritmo-lzw" id="toc-fluxo-do-algoritmo-lzw" class="nav-link" data-scroll-target="#fluxo-do-algoritmo-lzw">Fluxo do Algoritmo LZW</a>
  <ul class="collapse">
  <li><a href="#compressão" id="toc-compressão" class="nav-link" data-scroll-target="#compressão">Compressão</a></li>
  <li><a href="#descompressão" id="toc-descompressão" class="nav-link" data-scroll-target="#descompressão">Descompressão</a></li>
  </ul></li>
  <li><a href="#execução" id="toc-execução" class="nav-link" data-scroll-target="#execução">Execução</a>
  <ul class="collapse">
  <li><a href="#comando-de-compressão" id="toc-comando-de-compressão" class="nav-link" data-scroll-target="#comando-de-compressão">Comando de Compressão</a></li>
  <li><a href="#comando-de-descompressão" id="toc-comando-de-descompressão" class="nav-link" data-scroll-target="#comando-de-descompressão">Comando de Descompressão</a></li>
  </ul></li>
  <li><a href="#testes" id="toc-testes" class="nav-link" data-scroll-target="#testes">Testes</a>
  <ul class="collapse">
  <li><a href="#métodos" id="toc-métodos" class="nav-link" data-scroll-target="#métodos">Métodos</a></li>
  </ul></li>
  <li><a href="#resultados-e-discussão" id="toc-resultados-e-discussão" class="nav-link" data-scroll-target="#resultados-e-discussão">Resultados e Discussão</a>
  <ul class="collapse">
  <li><a href="#análises-por-tipo-de-arquivo" id="toc-análises-por-tipo-de-arquivo" class="nav-link" data-scroll-target="#análises-por-tipo-de-arquivo">Análises por Tipo de Arquivo</a></li>
  </ul></li>
  <li><a href="#conclusão" id="toc-conclusão" class="nav-link" data-scroll-target="#conclusão">Conclusão</a></li>
  <li><a href="#referências" id="toc-referências" class="nav-link" data-scroll-target="#referências">Referências</a></li>
  <li><a href="#anexos" id="toc-anexos" class="nav-link" data-scroll-target="#anexos">Anexos</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Relatório de Compressão e Descompressão com LZW</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Gustavo Chaves Ferreira e Julio Guerra Domingues </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">Invalid Date</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="algoritmo-de-compressão-lzw-com-trie-compacta" class="level1">
<h1>Algoritmo de Compressão LZW com Trie Compacta</h1>
<p><strong>Relatório</strong></p>
<p><strong>Gustavo Chaves Ferreira - 2022043329</strong><br>
<strong>Júlio Guerra Domingues - 2022431280</strong></p>
<hr>
<section id="introdução" class="level2">
<h2 class="anchored" data-anchor-id="introdução">Introdução</h2>
<p>Este relatório apresenta a implementação de um algoritmo de compressão de arquivos utilizando o método Lempel-Ziv-Welch (LZW). O foco principal é demonstrar como estruturas de dados, especificamente a trie compacta, podem ser empregadas para otimizar o processo de compressão e descompressão. Além disso, discutiremos os resultados obtidos a partir de testes realizados com diferentes tipos de arquivos, incluindo textos, imagens e arquivos binários, analisando em quais situações o algoritmo é mais ou menos eficiente.</p>
<hr>
</section>
<section id="descrição-do-algoritmo-lzw" class="level2">
<h2 class="anchored" data-anchor-id="descrição-do-algoritmo-lzw">Descrição do Algoritmo LZW</h2>
<p>O algoritmo LZW é um método de compressão sem perdas que substitui sequências repetidas de símbolos por códigos inteiros, reduzindo assim o tamanho total do arquivo. O algoritmo opera construindo um dicionário de sequências de caracteres à medida que percorre o arquivo de entrada. Inicialmente, o dicionário contém todas as possíveis representações de um único símbolo do alfabeto utilizado (no caso, os 256 símbolos da tabela ASCII).</p>
<section id="processo-de-compressão" class="level3">
<h3 class="anchored" data-anchor-id="processo-de-compressão">Processo de Compressão</h3>
<ol type="1">
<li><strong>Inicialização:</strong> O dicionário é inicializado com todas as sequências de comprimento um possíveis (símbolos ASCII).<br>
</li>
<li><strong>Leitura de Símbolos:</strong> O algoritmo lê os símbolos de entrada um a um, construindo sequências concatenadas.<br>
</li>
<li><strong>Verificação no Dicionário:</strong> Se a sequência atual existe no dicionário, o algoritmo continua concatenando o próximo símbolo.<br>
</li>
<li><strong>Atualização do Dicionário:</strong>
<ul>
<li>Adiciona a nova sequência ao dicionário com um novo código.<br>
</li>
<li>Emite o código correspondente à sequência anterior.<br>
</li>
<li>Reinicia a sequência com o símbolo atual.<br>
</li>
</ul></li>
<li><strong>Ajuste do Tamanho do Código:</strong> O algoritmo pode operar com tamanho de código fixo ou variável. Na implementação atual, utilizamos um tamanho de código variável, aumentando o número de bits conforme o dicionário cresce.</li>
</ol>
</section>
<section id="processo-de-descompressão" class="level3">
<h3 class="anchored" data-anchor-id="processo-de-descompressão">Processo de Descompressão</h3>
<ol type="1">
<li><strong>Inicialização:</strong> O dicionário é inicializado de forma semelhante à compressão.<br>
</li>
<li><strong>Leitura de Códigos:</strong> O algoritmo lê os códigos do arquivo comprimido.<br>
</li>
<li><strong>Reconstrução das Sequências:</strong> Com base nos códigos e no dicionário, o algoritmo reconstrói as sequências originais.<br>
</li>
<li><strong>Atualização do Dicionário:</strong> Novas sequências são adicionadas ao dicionário à medida que são descobertas.</li>
</ol>
<hr>
</section>
</section>
<section id="implementação" class="level2">
<h2 class="anchored" data-anchor-id="implementação">Implementação</h2>
<p>As classes <code>CompactTrie</code> e <code>CompactTrieNode</code> formam a estrutura de dados base para gerenciar prefixos binários de forma eficiente. A classe <code>TrieLZW</code> utiliza esta Trie para implementar o algoritmo de compressão LZW, otimizando armazenamento e buscas durante compressão e descompressão.</p>
<section id="detalhes-da-implementação" class="level3">
<h3 class="anchored" data-anchor-id="detalhes-da-implementação">Detalhes da Implementação</h3>
<ul>
<li><strong>Linguagem:</strong> Python.<br>
</li>
<li><strong>Manipulação de Bits:</strong> Utilização de strings binárias para representar sequências e códigos.<br>
</li>
<li><strong>Tamanho do Código:</strong> Implementação com tamanho de código variável, iniciando com 9 bits e aumentando conforme o dicionário cresce.<br>
</li>
<li><strong>Entrada/Saída:</strong> O programa recebe parâmetros via linha de comando, permitindo especificar arquivos de entrada, saída e configurações opcionais.<br>
</li>
<li><strong>Estatísticas:</strong> Durante a compressão e descompressão, estatísticas como taxa de compressão, tamanho do dicionário, tempo de execução e uso de memória são coletadas.</li>
</ul>
<hr>
</section>
</section>
<section id="principais-classes" class="level2">
<h2 class="anchored" data-anchor-id="principais-classes">Principais Classes</h2>
<section id="classe-compacttrienode" class="level3">
<h3 class="anchored" data-anchor-id="classe-compacttrienode">Classe <code>CompactTrieNode</code></h3>
<p>Essa classe representa os nós de uma Trie Compacta Binária.<br>
- <strong>Atributos:</strong><br>
- <code>children</code>: Uma lista de dois filhos binários (0 ou 1), inicializados como <code>None</code>.<br>
- <code>binary_string</code>: String binária representando o prefixo associado ao nó.<br>
- <code>value</code>: Valor armazenado no nó, utilizado para buscas e compressão.<br>
- <code>is_leaf</code>: Indicador booleano se o nó é uma folha.<br>
- <code>unique_id</code>: Um identificador único gerado automaticamente para o nó (usado para visualização).</p>
</section>
<section id="classe-compacttrie" class="level3">
<h3 class="anchored" data-anchor-id="classe-compacttrie">Classe <code>CompactTrie</code></h3>
<p>Implementa uma Trie Compacta Binária, otimizando buscas e inserções baseadas em prefixos binários.<br>
- <strong>Principais Métodos:</strong><br>
- <code>get_common_prefix_length(key1, key2)</code>: Retorna o comprimento do prefixo comum entre duas strings binárias, essencial para dividir ou inserir nós.<br>
- <code>search(key)</code>: Busca um nó na Trie com o exato prefixo igual a <code>key</code>. Retorna o nó encontrado ou <code>None</code> se a chave não existe.<br>
- <code>insert(key, value)</code>: Insere um novo nó com a string binária <code>key</code> e o valor <code>value</code>.<br>
- <code>delete_key(key)</code>: Remove uma chave <code>key</code> da Trie.<br>
- <code>visualize(filename)</code>: Gera uma visualização da Trie em formato gráfico (.png) utilizando o graphviz, para debug. Cada nó é rotulado com seu prefixo e, caso seja folha, o valor associado.</p>
</section>
<section id="classe-trielzw" class="level3">
<h3 class="anchored" data-anchor-id="classe-trielzw">Classe <code>TrieLZW</code></h3>
<p>Implementa o algoritmo LZW, utilizando uma Trie Compacta Binária como dicionário dinâmico.<br>
- <strong>Principais Métodos:</strong><br>
- <code>compress(file_path, compression_type, codes_max_size)</code>: Aplica a compressão LZW em um arquivo de entrada. Lida com os diferentes tipos de compressão (estática e dinâmica). O arquivo comprimido é salvo em formato binário (.bin), com cabeçalho indicando o tamanho do padding utilizado.<br>
- <code>decompress(file_path, compression_type, original_file_name, original_file_extension, codes_max_size)</code>: Restaura o arquivo original a partir de um arquivo comprimido. Reconstrói os símbolos originais com base nos códigos comprimidos. Gerencia expansão ou reset do dicionário conforme o tipo de compressão. O arquivo descomprimido é salvo com a extensão original.</p>
<hr>
</section>
</section>
<section id="fluxo-do-algoritmo-lzw" class="level2">
<h2 class="anchored" data-anchor-id="fluxo-do-algoritmo-lzw">Fluxo do Algoritmo LZW</h2>
<section id="compressão" class="level3">
<h3 class="anchored" data-anchor-id="compressão">Compressão</h3>
<ol type="1">
<li>Inicializa um dicionário com todas as combinações ASCII.<br>
</li>
<li>Lê o arquivo original byte a byte, criando sequências de símbolos.<br>
</li>
<li>Para cada nova sequência:
<ul>
<li>Se a sequência estiver no dicionário, continua adicionando símbolos.<br>
</li>
<li>Caso contrário, adiciona a sequência ao dicionário com um novo código.<br>
</li>
</ul></li>
<li>Salva os códigos resultantes em um arquivo binário comprimido.</li>
</ol>
</section>
<section id="descompressão" class="level3">
<h3 class="anchored" data-anchor-id="descompressão">Descompressão</h3>
<ol type="1">
<li>Inicializa um dicionário idêntico ao da compressão.<br>
</li>
<li>Lê os códigos do arquivo comprimido e busca as sequências correspondentes no dicionário.<br>
</li>
<li>Adiciona novas sequências ao dicionário conforme os códigos são interpretados.<br>
</li>
<li>Reconstrói o conteúdo original e o salva no formato correspondente.</li>
</ol>
<hr>
</section>
</section>
<section id="execução" class="level2">
<h2 class="anchored" data-anchor-id="execução">Execução</h2>
<section id="comando-de-compressão" class="level3">
<h3 class="anchored" data-anchor-id="comando-de-compressão">Comando de Compressão</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python3</span> lzw.py compress <span class="op">&lt;</span>arquivo_a_ser_comprimido.<span class="pp">*</span><span class="op">&gt;</span> <span class="op">&lt;</span>arquivo_comprimido.bin<span class="op">&gt;</span> --stats-file <span class="op">&lt;</span>arquivo_com_estatisticas.json<span class="op">&gt;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="descrição" class="level4">
<h4 class="anchored" data-anchor-id="descrição">Descrição</h4>
<ul>
<li><strong><code>compress</code></strong>: Indica que o programa realizará a compressão do arquivo.<br>
</li>
<li><strong><code>&lt;arquivo_a_ser_comprimido.*&gt;</code></strong>: Caminho do arquivo de entrada que será comprimido.<br>
</li>
<li><strong><code>&lt;arquivo_comprimido.bin&gt;</code></strong>: Caminho onde o arquivo comprimido será salvo.<br>
</li>
<li><strong><code>--stats-file &lt;arquivo_com_estatisticas.json&gt;</code></strong>: (Opcional) Especifica o arquivo JSON onde as estatísticas da compressão, como tamanho inicial e comprimido, serão salvas.</li>
</ul>
</section>
</section>
<section id="comando-de-descompressão" class="level3">
<h3 class="anchored" data-anchor-id="comando-de-descompressão">Comando de Descompressão</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python3</span> lzw.py decompress <span class="op">&lt;</span>arquivo_comprimido.bin<span class="op">&gt;</span> <span class="op">&lt;</span>arquivo_descomprimido.<span class="pp">*</span><span class="op">&gt;</span> --max-bits <span class="op">&lt;&gt;</span> --stats-file <span class="op">&lt;</span>arquivo_com_estatísticas.json<span class="op">&gt;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="descrição-1" class="level4">
<h4 class="anchored" data-anchor-id="descrição-1">Descrição</h4>
<ul>
<li><strong><code>decompress</code></strong>: Indica que o programa realizará a descompressão do arquivo.<br>
</li>
<li><strong><code>&lt;arquivo_a_ser_descomprimido.bin&gt;</code></strong>: Caminho do arquivo comprimido que será descomprimido.<br>
</li>
<li><strong><code>&lt;arquivo_descomprimido.*&gt;</code></strong>: Caminho onde o arquivo descomprimido será salvo.<br>
</li>
<li><strong><code>--max-bits &lt;&gt;</code></strong>: Define o tamanho máximo dos códigos (em bits) utilizados na descompressão.<br>
</li>
<li><strong><code>--stats-file &lt;arquivo_com_estatísticas.json&gt;</code></strong>: (Opcional) Especifica o arquivo JSON onde as estatísticas da descompressão, como tamanho do arquivo comprimido e descomprimido, serão salvas.</li>
</ul>
</section>
</section>
</section>
<section id="testes" class="level2">
<h2 class="anchored" data-anchor-id="testes">Testes</h2>
<section id="métodos" class="level3">
<h3 class="anchored" data-anchor-id="métodos">Métodos</h3>
<p>O código foi instrumentado para monitorar os tempos de compressão e descompressão, razão de compressão, tamanho do dicionário e uso de memória. Para cada arquivo descomprimido, foi verificada a integridade a partir da comparação binária, para assegurar que os dados originais foram recuperados sem perdas.</p>
<p>Tais variáveis foram avaliadas em arquivos de diferentes tipos e tamanhos, de forma a verificar o desempenho do algoritmo em diferentes cenários. Foram realizados testes com arquivos de texto (.txt), imagem (.bmp, .pgm), áudio (.wav) e binários (.bin). Outros formatos comuns de arquivos, como .jpg, .png e .mpg, não foram testados pois já apresentam compressão (com ou sem perdas), o que influenciaria no comportamento do programa e prejudicaria as análises.</p>
<hr>
</section>
</section>
<section id="resultados-e-discussão" class="level2">
<h2 class="anchored" data-anchor-id="resultados-e-discussão">Resultados e Discussão</h2>
<p>A eficiência do algoritmo LZW é altamente dependente das características dos dados de entrada. A seguir, discutimos como diferentes fatores influenciam a taxa de compressão em textos, imagens e arquivos binários. A respeito das duas variantes do algoritmo, a versão dinâmica se demonstrou mais atrativa do que sua variável estática nos momentos em que os limites para tamanho de código máximo não ultrapassaram a faixa de 16 a 20 bits. O uso de tamanhos de códigos variáveis associados a uma escolha ponderada de um teto de crescimento apresentaram melhores taxas de compressão em comparação à alternativa de sempre emitir códigos de 12 bits para a maioria dos casos. Vale ressaltar que o uso de memória pode se tornar um problema caso o dicionário representado pela árvore de prefixos cresça de forma preponderante. Ademais, códigos muito extensos tendem a anular o efeito da compressão para execuções muito longas. Para se ter uma ideia do desempenho do LZW para os casos principais de texto (‘.txt’) e de imagem (‘.bmp’), o algoritmo no caso estático teve os seguintes resultados:</p>
<p>O arquivo de texto “test_text.txt” com 200 mil caracteres apresentou uma redução de 200000 bytes para 59537 bytes. A imagem “imagemhomog_30kb.bmp” de tamanho inicial 282062 bytes se reduziu para 3417 bytes (a redundância foi bem aproveitada).</p>
<p>Para formatos de arquivo mais variados, algumas estatísticas obtidas estão representadas abaixo. Elas são seguidas por comentários a respeito de cada formato.</p>
<section id="tabelas-resumidas" class="level4">
<h4 class="anchored" data-anchor-id="tabelas-resumidas">Tabelas Resumidas</h4>
<p><strong>Compressão:</strong></p>
<p><strong>Descompressão:</strong></p>
<hr>
</section>
<section id="análises-por-tipo-de-arquivo" class="level3">
<h3 class="anchored" data-anchor-id="análises-por-tipo-de-arquivo">Análises por Tipo de Arquivo</h3>
<section id="textos" class="level4">
<h4 class="anchored" data-anchor-id="textos">Textos</h4>
<p>Textos com muitas repetições, como documentos com vocabulário limitado ou formatos estruturados (como XML ou JSON), tendem a ser mais compressíveis. Isso ocorre porque o LZW aproveita sequências repetidas para construir um dicionário mais eficiente. Textos ricos em vocabulário, como obras literárias, têm menos repetições e, portanto, menor taxa de compressão.</p>
</section>
<section id="imagens" class="level4">
<h4 class="anchored" data-anchor-id="imagens">Imagens</h4>
<p>Imagens com áreas grandes de cor uniforme, como gráficos ou desenhos animados, são mais compressíveis. Já imagens fotográficas, com variação de cores e detalhes finos, oferecem menos oportunidades para compressão. Imagens em escala de cinza ou monocromáticas têm menos informações por pixel do que imagens coloridas, resultando em maior taxa de compressão. Imagens já comprimidas em formatos como JPEG ou PNG (que usam compressão com perdas e sem perdas, respectivamente) podem não ser eficazmente comprimidas novamente pelo LZW.</p>
</section>
<section id="áudio" class="level4">
<h4 class="anchored" data-anchor-id="áudio">Áudio</h4>
<p>A compressão de arquivos WAV utilizando o algoritmo LZW é influenciada principalmente pela redundância dos dados de áudio, parâmetros de gravação como taxa de amostragem e profundidade de bits, complexidade do conteúdo de áudio, e configurações do algoritmo LZW. Arquivos WAV com alta redundância e padrões repetitivos são mais eficazmente comprimidos pelo LZW, enquanto aqueles com alta entropia e variações rápidas apresentarão menores taxas de compressão.</p>
</section>
<section id="arquivos-binários" class="level4">
<h4 class="anchored" data-anchor-id="arquivos-binários">Arquivos Binários</h4>
<p>Arquivos binários com dados aleatórios ou já comprimidos (como arquivos ZIP ou executáveis) possuem alta entropia, o que torna a compressão adicional ineficiente. Se o arquivo binário contém estruturas repetitivas ou padrões previsíveis, o LZW pode obter alguma compressão. Arquivos binários que representam dados estruturados (por exemplo, registros com campos fixos) podem ser mais suscetíveis à compressão.</p>
</section>
<section id="outras-análises" class="level4">
<h4 class="anchored" data-anchor-id="outras-análises">Outras Análises</h4>
<p>Observa-se que a taxa de compressão tende a estabilizar conforme o dicionário cresce e o algoritmo encontra sequências repetidas mais longas. Em arquivos com alta redundância, a taxa de compressão inicial é mais acentuada. O crescimento do dicionário é mais rápido em arquivos com muitos padrões únicos, o que pode afetar o desempenho em termos de memória.</p>
<hr>
</section>
</section>
</section>
<section id="conclusão" class="level2">
<h2 class="anchored" data-anchor-id="conclusão">Conclusão</h2>
<p>A implementação do algoritmo LZW utilizando uma trie compacta demonstrou-se eficaz na compressão de arquivos de diferentes tipos. A estrutura de dados escolhida permitiu otimizar as operações críticas do algoritmo, resultando em tempos de execução aceitáveis e uso de memória controlado. Os testes realizados confirmaram a correta funcionalidade do algoritmo, preservando a integridade dos dados após a compressão e descompressão. Observou-se que a eficiência da compressão varia conforme o tipo de arquivo e suas características intrínsecas, sendo mais eficaz em dados com alta redundância. Enquanto métodos como o LZW oferecem uma base sólida e flexibilidade, o avanço contínuo na tecnologia de compressão tem permitido o desenvolvimento de soluções mais especializadas e eficientes para domínios específicos. Assim, a escolha informada do método de compressão não apenas maximiza a eficiência do armazenamento, mas também preserva a integridade e qualidade dos dados de maneira mais eficaz.</p>
<hr>
</section>
<section id="referências" class="level2">
<h2 class="anchored" data-anchor-id="referências">Referências</h2>
<ol type="1">
<li>Lempel A, Ziv J. Compression of Individual Sequences via Variable-Rate Coding. IEEE Transactions on Information Theory, 1978.<br>
</li>
<li><a href="https://www2.cs.uic.edu/~i101/SoundFiles/">CS Sound Files</a><br>
</li>
<li><a href="https://web.mit.edu/6.02/www/s2012/handouts/3.pdf">MIT Lecture Notes</a><br>
</li>
<li><a href="https://www.davidsalomon.name/DC4advertis/DComp4Ad.html">David Salomon - Data Compression</a></li>
</ol>
<hr>
</section>
<section id="anexos" class="level2">
<h2 class="anchored" data-anchor-id="anexos">Anexos</h2>
<ul>
<li><strong>Código Fonte:</strong> Disponível no GitHub.<br>
</li>
<li><strong>Estatísticas Detalhadas:</strong> Os arquivos utilizados nos testes e JSON com dados completos das execuções estão disponíveis na pasta <code>/tests</code>.</li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>